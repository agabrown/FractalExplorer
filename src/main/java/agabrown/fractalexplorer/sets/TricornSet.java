/**
 *
 */
package agabrown.fractalexplorer.sets;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents the Tricorn or Mandelbar set in which the set is generated by
 * iterating the conjugate of z in the Mandelbrot equation.
 *
 * @author agabrown
 *
 */
public final class TricornSet implements FractalSet {

  /**
   * Upper limit on magnitude of the complex numbers that can belong to the
   * TricornSet set.
   */
  private static final double BOUND = 2.0;

  /**
   * Upper limit on square of the magnitude of the complex numbers that can
   * belong to the Tricorn set.
   */
  private static final double BOUND_SQUARE = BOUND * BOUND;

  /**
   * The name of this fractal set.
   */
  private static final String NAME = "Tricorn set";

  /**
   * Unicode code for the letter &mu;.
   */
  private static final int MU_UNICODE = 0x03BC;

  /**
   * Contains the info text lines.
   */
  private ArrayList<String> infoLines;

  /**
   * Real part of Julia set parameter &mu;.
   */
  private final double muReal;

  /**
   * Imaginary part of Julia set parameter &mu;.
   */
  private final double muImaginary;

  /**
   * Default constructor. Sets the &mu; parameter to 0+i*0.
   */
  public TricornSet() {
    this(0.0, 0.0);
  }

  /**
   * Constructor. Sets the value for &mu;.
   *
   * @param muRe
   *          Real part of &mu;.
   * @param muIm
   *          Imaginary part of &mu;.
   */
  public TricornSet(final double muRe, final double muIm) {
    muReal = muRe;
    muImaginary = muIm;
    intializeInfoLines();
  }

  /*
   * (non-Javadoc)
   * 
   * @see agabrown.fractalexplorer.sets.FractalSet#isPointInSet(double, double,
   * int)
   */
  @Override
  public boolean isPointInSet(final double real, final double imaginary, final int maxIter) {
    if (iterateSeries(real, imaginary, maxIter) >= maxIter) {
      return true;
    } else {
      return false;
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see
   * agabrown.fractalexplorer.sets.FractalSet#numberOfIterationsForPoint(double,
   * double, int)
   */
  @Override
  public int numberOfIterationsForPoint(final double real, final double imaginary, final int maxIter) {
    return iterateSeries(real, imaginary, maxIter);
  }

  /*
   * (non-Javadoc)
   * 
   * @see agabrown.fractalexplorer.sets.FractalSet#getName()
   */
  @Override
  public String getName() {
    return NAME;
  }

  /*
   * (non-Javadoc)
   * 
   * @see agabrown.fractalexplorer.sets.FractalSet#getInfoLines()
   */
  @Override
  public List<String> getInfoLines() {
    return infoLines;
  }

  /**
   * Initialize the constant parts of the lines with information on the Julia
   * Set parameters.
   */
  private void intializeInfoLines() {
    infoLines = new ArrayList<>();
    StringBuilder line = new StringBuilder("Re(");
    line.appendCodePoint(MU_UNICODE);
    line.append(") = ");
    line.append(muReal);
    infoLines.add(line.toString());
    line = new StringBuilder("Im(");
    line.appendCodePoint(MU_UNICODE);
    line.append(") = ");
    line.append(muImaginary);
    infoLines.add(line.toString());
    infoLines.trimToSize();
  }

  /**
   * Check if the complex input number is in the TricornSet set. Use the fast
   * approach using doubles and the worked out formula for updating the complex
   * number series.
   *
   * @param real
   *          Real part of complex number to check
   * @param imaginary
   *          Imaginary part of complex number to check
   * @param maxIter
   *          Maximum number of iterations to decide on whether or not the
   *          number is in the set. Numbers for which maxIter is exceeded are
   *          considered to be part of the set.
   *
   * @return Number of iterations used.
   */
  private int iterateSeries(final double real, final double imaginary, final int maxIter) {
    int iter = 0;
    double zReal = real;
    double zImaginary = imaginary;
    double zRealTemp;
    while (zReal * zReal + zImaginary * zImaginary <= BOUND_SQUARE && iter < maxIter) {
      zRealTemp = zReal * zReal - zImaginary * zImaginary + real;
      zImaginary = -2.0 * zReal * zImaginary + imaginary;
      zReal = zRealTemp;
      iter = iter + 1;
    }
    return iter;
  }

}
